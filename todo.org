#+title: Todo

* TODO fucking important [2/10]
** TODO Unions [1/3]
in terms of representation, we just need =Vec<Value>= for now. later we can do specialization for common like =T | undefined=

*** DONE normalizing unions
*** TODO object edge case
this is a weird edge case:
#+begin_src typescript
type Extends<A, B> = A extends B ? "extends" : "not extends";

type a = { foo: 1 | 2 };
type b = { foo: 1 } | { foo: 2 };

// extends
type result = Extends<a, b>;
#+end_src

if we do the algorithm on objects where we check every key of =a= is subtype of every variant of union =b= it will fail, because:
#+begin_src typescript
// not extends
type result = Extends<1 | 2, 1>
// not extends
type result2 = Extends<1 | 2, 2>
#+end_src

there are a couple ways to solve this:
- specialized subtype impl for objects vs unions ::
  how would this look like?

  first we need to know when do apply this specialization. we need to be able to tell if =a= is an obect and =b= is a union of N objects where each object has a similar field but with different values.

  when we know the conditions for this specialization are met, then we dispatch to =extends_object_union= function.

  this will iterate the keys of =a=. if one key has a value that is a union, we check if the value subtypes the corresponding value in =b=.

- when "normalizing" unions we turn ={ foo: 1 } | { foo: 2 }= into ={ foo: 1 | 2 }=, or do this just before subtype checking
*** TODO disjoint edge case
if two unions are disjoint:
#+begin_src typescript
type ExtendsCheck<A, B> = A extends B ? "yes" : "no";
type t5 = ExtendsCheck<
  "NICE" | boolean | { lmao: boolean },
  string | boolean | number | { nice: string }
>;
#+end_src

the result is: "yes" | "no"

** DONE Unable to distinguish arrays and single-item tuples
I realized I made a very naive error in the way arrays/tuples are represented, which means that single-items and regular arrays are indistinguishable from each other which is bad.
** TODO Non-object type keys
all types are actually objects and have additional keys

for example =number= has =toExponential=, =toFixed=, etc.

so each type has like its base number of keys, so we dont have to make every type an =Object=, instead when we type check =string=, =bool=, =number=, etc. against object we just check against these known base keys

the problem is when you add more types to this base amount:
#+begin_src typescript
type agumentednumber = number & { foo(): void }
#+end_src

We have several options:
1. put a =base= field on the =Object= struct which tells us where to get the base keys ::
   problem is that =number=, =string= aren't actually objects see the Test<A, B> thing below. you can't make an
   object with all the fields of a number and have it be a number

   so we want to still have our distinction
2. or just merge the base keys onto the =fields= of an =Object= ::
   same problem as above
3. create an "augmented" type which contains the type and additional fields ::
   Something like this:
    #+begin_src rust
    struct AugmentedType {
        base: Value,
        augmentation: Object
    }
    #+end_src

4. have special heap allocated variants of keyword types =Number=, =String=, =Boolean=

#+begin_src typescript
type Test<A, B> = A extends B ? "extends" : "not extends";
type fakenumber = {
  toExponential(fractionDigits?: number | undefined): string;
  toFixed(fractionDigits?: number | undefined): string;
  toLocaleString(
    locales?: string | string[] | undefined,
    options?: Intl.NumberFormatOptions | undefined
  ): string;
  toPrecision(precision?: number | undefined): string;
  toString(radix?: number | undefined): string
  valueOf(): number
};

// this returns "not extends"
type result = Test<fakenumber, number>
#+end_src
** TODO Optional fields/types
we have optional types:
#+begin_src typescript
type OptionalInObject = {
  foo?: boolean
}
type OptionalInTuple = [foo?: string]
#+end_src

how do we handle this?

first intuition is to treat them as union like: =T | undefined=.
indeed, when you hover over =OptionalInObject= or =OptionalInTuple=, the optional fields become: =foo?: boolean | undefined=
but we need to make sure that the semantics between =foo?: boolean= and this union represenation map over sufficiently enough to do this.
basically what i want to know is if we can erase the concept of "optionals" completely from the IR and treat them literally as =T | undefined=

the issue is that an optional field actually allows you to omit the field in instantiating the type:
#+begin_src typescript
// is okay
const test: OptionalInObject = {}

type NOOptionalInObject = {
  foo: boolean | undefined
}
// not okay, complains we are missing `foo`
const notOkay: OptionalInObject = {}
#+end_src

and I made sure to check this was the same in type-level typescript:
#+begin_src typescript
type OptionalInObject = {
  optional?: boolean;
};
type NOOptionalInObject = {
  optional: boolean | undefined;
};

type Check<T> = T extends NOOptionalInObject ? "YAY" : "NOO";
// result is NOO
type CheckResult = Check<{}>;
#+end_src

so we need to preserve this optional information
** TODO Recursive function argument =extends= optimization
When recursively calling a function, the =extends= check may be redundantly called:
#+begin_src typescript
type FillArrayImpl<
  Count extends number,
  I extends number,
  Value,
  Array extends any[]
> = I extends Count
  ? Array
  : FillArrayImpl<Count, Add<I, 1>, Value, [Value, ...Array]>;
#+end_src

In the above example, when =FillArrayImpl<...>= is recursively called, all of its arguments will undergo a needless extends check.

We can optimize them away.

In the most trivial case, identifiers that are reused can have their extends check omitted. For example, =Count= is untouched and passed again to =FillArrayImpl=. When we first call =FillArrayImpl=, we check =Count extends number=, then we don't touch it and then pass it again to the function.

These optimizations would require a refactor to /when/ the extends check takes place. Right now, the checks happen /inside/ the function. We'll have to do them /before/ the function.
** TODO Template literals with non-literal types
Template literals work with literal types:
#+begin_src typescript
// "hehe 420"
type foo = `hehe ${420}`
#+end_src

But when a non-literal type is added, the type stays as a template literal type:
#+begin_src typescript
// "hehe ${any}"
type foo = `hehe ${any}`
#+end_src

You can still concat new strings though:

#+begin_src typescript
// `hehe ${any}wow 420`
type lmao = `${foo}wow ${420}`
#+end_src
** TODO Index numeric literals optimization
can speed up index operations if we make specialization ops for indexing

for example =myarray[0]= is a common expression, specifically indexing with a number constant literal
** TODO Accessing =length= key on arrays
** TODO GC
* TODO brainstorming
** TODO use immutable / persistent data structures
all values in type-level typescript are immutable. langs with focus on immutability tend to be allocation heavy (you need to make more objects)

fp langs solve this by using persistent data structures which typically have some structural sharing mechanism to reduce allocations for copies

https://github.com/immutable-js/immutable-js/ readme links:
- hash map tries ([[https://en.wikipedia.org/wiki/Hash_array_mapped_trie][link]])
- vector tries ([[https://hypirion.com/musings/understanding-persistent-vector-pt-1][link]])

there are some rust crates that implement persistent data structures, but they are designed for safe rust.  they all have some reference counting shit going on. i don't know

** TODO idea for using stack for objects
what if the key/vals for an object were a slice/window of the stack?
** TODO Make ir repr more compact
some places where we can box stuff
* TODO archive
** DONE String interpolation
** DONE string interning
this is really important, otherwise string value equality won't work
** DONE globals non-forward declarations all fucked lol
evaluation of order can't be strictly top down

this a little more complicated

need to build DAG of global declarations and the declarations they depend on

What to do with this?
#+begin_src typescript
type Fib<X extends number> = FibIter<X, 2, 1, 0>
type FibIter<X, I, Prev, PrevPrev> = /* ... */
type Main = WriteFile<
  "./fib-result.ts",
  ToTypescriptSource<"FibonacciResult", Fib<amount>>
>;

type amount = Main;
#+end_src

all globals will be the roots of the stmt nodes
process them first, add to =globals=
then when actually compiling the global, need to check if we already compiled so we dont have people redefining vars

** DONE main argv
** DONE let decls
this is my strategy:

executing a let decl will add another local to the function.
since we have the requirement that all exprs when finished executing will leave the stack as it was before, we can be certain that
pushing this local to the stack will be after the locals of the params + any other locals form let decls:
#+begin_src bash
STACK:
param1 param2 param3 letdecl1 letdecl2 letdecl3
#+end_src

when you enter the true branch of a let decl, we should push that local
#+begin_src typescript
type TestLet<Arg> = Arg extends infer val extends 0 ? val : "nope";
#+end_src
(the new bound var doesn't exist in the else branch)

the only problem is then getting rid of these new let decl vars.

** DONE arrays
to store we just need a vec of types

there are three kinds of arrays:
1. =Array<T>= or =T[]=
2. =[T, K, etc]=
3. =[and: T, labeled: K, etc]=

2 & 3 are actually tuples, but we should treat them the same bc they tuple extends array

also note that the labels in tuples dont matter for typechecking, they are just to make shit readable. so we can store them elsewhere and not give a fuck.

we could make a inline special representation. =Vec= is 24 bytes. =Value= is 8
usually the array type is just a =Value=
if its a tuple with 2-3 elements we can inline it probably
else just pass the =Vec=

we shouldnt even use vec (because of borrowck)
instead we can use our own repr with ptr + len

also

** DONE Handle spread properly
Problem is spread can be in any arbitrary position in array literal, not just end:
#+begin_src typescript
type foo = [...Lol, 1, 2, ...Lmao, 4, 5, ...Nice]
#+end_src

The problem is knowing at runtime which elements are spread elements, and which are regular types and shouldn't be spread.

- One idea is to pass this information as instruction operands ::
  You pass the indices of the spread arguments as instruction operands. I see two options:
  - pass them in as bit sets
  - pass them in as count + N indices
